**方法：排序 + 贪心。**

这道题其实和 [无重叠区间](435.无重叠区间.md) 非常像，可以进行以下转换。这道题可以转换成有多少个不重叠（不包括首尾相接的区间）的区间，有多少个不相接的区间就使用多少个箭可以了。

将区间按照右端点从小到大排序，每次都把箭放在这个区间的最右端进行遍历，因为这个位置是最右端能够包含的区间数目是最大的。

当有区间重叠时右边节不需要变动，或者说是等于多个重叠区间的最小值（因为已经按照右端点从小到大排序且从左开始遍历，所以不变就是相当于取最小值），因为如果取最大值可能导致计算错误。例如[1, 5]、[2, 8]、[6, 7] 前两个区间是重叠的，在5这个位置放一箭，在6~7之间放一箭，一共两箭。但是如果取最大值就会得到只要放一箭就能把这三个区间的气球打下来的错误结果。

这道题还要注意排序器的重写方式，要用两个值比较返回正负值的方式，而不要用两数相减的方式，因为对于`[[-2147483646,-2147483645],[2147483646,2147483647]]` 这个例子会溢出。

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, new Comparator<int[]>() {
            public int compare(int[] nums1, int[] nums2) {
                return nums1[1] > nums2[1] ? 1 : -1;
            }
        });
        int cnt = 1, right = points[0][1];
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > right) {
                cnt++;
                right = points[i][1];
            }
        }
        return cnt;
    }
}
```



Comparator重写compare方法，根据compare返回值判断是否需要排序，返回正值则需要排序。

① num1 > num2，这时num1 - num2 > 0，这时还需要排序的说明本应该小在前，大在后。所以是从小到大排序

② num2 > num1，这时num2 - num1 > 0，这时还需要排序则说明本应该大在前，小在后。所以是从大到小排序